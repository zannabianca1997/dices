//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.2

use chrono::{DateTime, FixedOffset};
use dices_engine::Engine;
use dices_server_intrisics::{ServerIntrisics, ServerIntrisicsDryData, ServerRng};
use sea_orm::{entity::prelude::*, sea_query::ValueType, TryGetable};

use crate::session::SessionId;

#[derive(Clone, Debug, DeriveEntityModel, PartialEq, Eq)]
#[sea_orm(schema_name = "public", table_name = "engine")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub session_id: SessionId,
    pub created_at: DateTime<FixedOffset>,
    pub last_command_at: Option<DateTime<FixedOffset>>,
    #[sea_orm(column_type = "VarBinary(StringLen::None)")]
    pub state: DatabaseEngine,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::session::Entity",
        from = "Column::SessionId",
        to = "super::session::Column::Id",
        on_update = "Cascade",
        on_delete = "Cascade"
    )]
    Session,
}

impl Related<super::session::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Session.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct DatabaseEngine(pub Engine<ServerRng, ServerIntrisics, ServerIntrisicsDryData>);

impl From<DatabaseEngine> for sea_orm::Value {
    fn from(source: DatabaseEngine) -> Self {
        bincode::encode_to_vec(source.0, bincode::config::standard())
            .expect("The encoding should be infallible")
            .into()
    }
}

impl TryGetable for DatabaseEngine {
    fn try_get_by<I: sea_orm::ColIdx>(
        res: &QueryResult,
        index: I,
    ) -> Result<Self, sea_orm::TryGetError> {
        Vec::<u8>::try_get_by(res, index).and_then(|bytes| {
            let engine = bincode::decode_from_slice(&bytes, bincode::config::standard())
                .map_err(|err| {
                    tracing::error!(
                        err = { &err as &dyn std::error::Error },
                        "Invalid engine state found in the database"
                    );
                    sea_orm::DbErr::Custom("Invalid engine state fetched".to_owned())
                })?
                .0;
            Ok(Self(engine))
        })
    }
}

impl ValueType for DatabaseEngine {
    fn try_from(v: sea_orm::Value) -> std::result::Result<Self, sea_orm::sea_query::ValueTypeErr> {
        let bytes = <Vec<u8> as sea_orm::sea_query::ValueType>::try_from(v)?;
        let engine = bincode::decode_from_slice(&bytes, bincode::config::standard())
            .map_err(|err| {
                tracing::error!(
                    err = { &err as &dyn std::error::Error },
                    "Invalid engine state found in the database"
                );
                sea_orm::sea_query::ValueTypeErr
            })?
            .0;
        Ok(Self(engine))
    }
    fn type_name() -> std::string::String {
        "SerializedEngine".to_owned()
    }
    fn array_type() -> sea_orm::sea_query::ArrayType {
        Vec::<u8>::array_type()
    }
    fn column_type() -> sea_orm::sea_query::ColumnType {
        Vec::<u8>::column_type()
    }
}
