---
title: "`dices` datatypes"
---
# `dices` datatypes
`dices` supports eight different datatypes: `Null`, `Bool`, `Number`, `List`, `Map`, `String`, `Function` and `Intrisic`.
The type system tries to be as dynamic as possible: operators on numbers transparently converts boolean and single value lists into the needed type, and vice versa.

## Null
`Null` is the unit type. It can take a single value: `null`. It's returned by most functions that do not return any value, and it's the placeholder for functions that are not available.
The **REPL** usually do not print expressions returning `null`:
```dices
>> null
>>
```

## Bool
The boolean type. It can take two values: `true` and `false`.
```dices
>> true
true
>> false
false
```
It's smoothly converted to the integer values `0` and `1`:
```dices
>> 3 + true
4
>> 3 + false
3
```

## Number
A 64-bits integer signed number. It supports the usual five integer operations: `+`, `-`, `*`, `/` and `%` (see [math](man://operators/math)).

## List
Heterogeneous lists. They can be inserted with the usual bracket notation:
```dices
>> [3,2,true, null]
[3, 2, true, null]
```
They are usually generated by repeated throws, made with the `^` operator (or its shorthand version for multiple dice)
```dices
>> 3^4
[3, 3, 3, 3]
>> 3d6
[3, 2, 6]
```
You can access list members both from the start and the end:
```dices
>> let l = [0,1,2,3];
>> l[1]
1
>> l[-1]
3
>> l.0 // shorthand for fixed indices
0
```
Sums work on lists by flattening them, so the dice sum notation (e.g `3d6 + 2`) is admitted
```dices
>> + [3,2]
5 
```
Negation, multiplications, divisions and remainder instead works member by member:
```dices
>> -[3,2,1] 
[-3, -2, -1]
>> [3,2,1] * 3
[9, 6, 3]
>> [3,2,1] / 3
[1, 0, 0]
>> [3,2,1] % 2
[1, 0, 1]
```
Another important class of operation on lists are filters. See [filters](man://operators/filters) for more.

## Map
Maps contains multiple values, giving a unique string name to every one of them. They can be inserted with the `<| .. |>` notation:
```dices
>> <| a:3, b:true , "hello world": null |>
<|a: 3, b: true, "hello world": null|>
```
As with lists, members can be accessed with a string index or the dot shorthand
```dices
>> let m = <| a:3, b:true , "hello world": true |>;
>> m["a"]
3
>> m.a
3
>> m."hello world"
true
```
The most common use of map are libraries: the `std` library is given as a map
```dices
>> std
<| .. |>
```

## String
Strings are unicode by default. They can be inserted with the usual quoted notation
```
>> "Hello World!"
"Hello World!"
```
Common escape codes are accepted (`\0`, `\n`, `\r`, `\t`, `\\`, `\"` and `\'`). Additionally, one can use hex escapes `\xHH` or unicode hex escapes `\u{HHHHHH}` to insert arbitrary unicode codepoints.
Strings are used both for map member access, and inputs to intrisic functions (like `help`).

## Function and Intrisics
`dices` supports closures using the `|..params| body` syntax. The body is evaluated at a later time, when the function is called:
```dices
>> let add_3 = |x| x+3;
>> add_3(4)
7
>> add_3(1)
4
```
Being closures, functions can capture the surrounding context:
```dices
>> let STR = 3;
>> let throw = || d6 + STR
|| {let STR = 3; (d(6)) + (STR)}
>> throw()
9
```
A special class of functions are the *intrisics*. One can find the available ones inside the std library, at `std.intrisics`.
They expose special capabilities of the engine. Examples are `print`, `quit` and `help`. See [intrisics](man://intrisics) for the complete list and more informations.
